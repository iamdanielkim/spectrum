{
  "name": "ace",
  "description": "Sinatra for Node",
  "version": "0.0.2",
  "author": {
    "name": "maccman"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/maccman/ace.git"
  },
  "main": "./lib/index.js",
  "bin": {
    "ace": "./bin/ace"
  },
  "dependencies": {
    "strata": "git://github.com/maccman/strata.git",
    "fibers": "git://github.com/laverdet/node-fibers.git#master",
    "mime": "1.2.4",
    "optimist": "0.3.1"
  },
  "readme": "Ace is [Sinatra](http://www.sinatrarb.com/) for Node; a simple web-server written in CoffeeScript with a straightforward API.\n\nEvery request is wrapped in a [Node Fiber](https://github.com/laverdet/node-fibers), allowing you to program in a synchronous manner without callbacks, but with all the advantages of an asynchronous web-server.\n\n    app.put '/posts/:id', ->\n      @post = Post.find(+@route.id).wait()\n      @post.updateAttributes(\n        name: @params.name,\n        body: @params.body\n      ).wait()\n      @redirect @post\n\nAce is built on top of the rock solid [Strata HTTP framework](http://stratajs.org/).\n\n##Examples\n\nYou can find an example blog app, including authentication and updating posts, in Ace's [examples directory](https://github.com/maccman/ace/tree/master/examples).\n\n##Usage\n\nNode >= v0.7.3 is required, as well as npm. Ace will run on older versions of Node, but will crash under heavy load due to a bug in V8 (now fixed).\n\nTo install, run:\n\n    npm install -g git://github.com/maccman/ace.git\n\n<!-- npm install -g ace -->\n\nTo generate a new app, run:\n\n    ace new myapp\n    cd myapp\n    npm install .\n\nTo serve up an app, run:\n\n    ace\n\n##Routing\n\nIn Ace, a route is a HTTP method paired with a URL matching pattern. For example:\n\n    app.get '/users', ->\n      'Hello World'\n\nAnything returned from a routing callback is set as the response body.\n\nYou can also specify a routing pattern, which is available in the callback under the `@route` object.\n\n    app.get '/users/:name', ->\n      \"Hello #{@route.name}\"\n\nPOST, PUT and DELETE callbacks are also available, using the `post`, `put` and `del` methods respectively:\n\n    app.post '/users', ->\n      @user = User.create(\n        name: @params.name\n      ).wait()\n      @redirect \"/users/#{@user.id}\"\n\n    app.put '/users/:id', ->\n      @user = User.find(+@route.id).wait()\n      @user.updateAttributes(\n        name: @params.name\n      ).wait()\n      @redirect \"/users/#{@user.id}\"\n\n    app.del '/user/:id', ->\n      @user = User.find(+@route.id).wait()\n      @user.destroy().wait()\n      @redirect \"/users\"\n\n##Parameters\n\nURL encoded forms, multipart uploads and JSON parameters are available via the `@params` object:\n\n    app.post '/posts', ->\n      @post = Post.create(\n        name: @params.name,\n        body: @params.body\n      ).wait()\n\n      @redirect \"/posts/#{@post.id}\"\n\n##Request\n\nYou can access request information using the `@request` object.\n\n    app.get '/request', ->\n      result =\n        protocol:     @request.protocol\n        method:       @request.method\n        remoteAddr:   @request.remoteAddr\n        pathInfo:     @request.pathInfo\n        contentType:  @request.contentType\n        xhr:          @request.xhr\n        host:         @request.host\n\n      @json result\n\nFor more information, see [request.js](https://github.com/mjijackson/strata/blob/master/lib/request.js).\n\nYou can access the full request body via `@body`:\n\n    app.get '/body', ->\n      \"You sent: #{@body}\"\n\nYou can check to see what the request accepts in response:\n\n    app.get '/users', ->\n      @users = User.all().wait()\n\n      if @accepts('application/json')\n        @jsonp @users\n      else\n        @eco 'users/list'\n\nYou can also look at the request format (calculated from the URL's extension). This can often give a better indication of what clients are expecting in response.\n\n      app.get '/users', ->\n        @users = User.all().wait()\n\n        if @format is 'application/json'\n          @jsonp @users\n        else\n          @eco 'users/list'\n\nFinally you can access the raw `@env` object:\n\n    @env['Warning']\n\n##Responses\n\nAs well as returning the response body as a string from the routing callback, you can set the response attributes directly:\n\n    app.get '/render', ->\n      @headers['Transfer-Encoding'] = 'chunked'\n      @contentType = 'text/html'\n      @status = 200\n      @body = 'my body'\n\nYou can set the `@headers`, `@status` and `@body` attributes to alter the request's response.\n\nIf you only need to set the status code, you can just return it directly from the routing callback. The properties `@ok`, `@unauthorized` and `@notFound` are aliased to their relevant status codes.\n\n    app.get '/render', ->\n      # ...\n      @ok\n\n##Static\n\nBy default, if a folder called `public` exists under the app root, its contents will be served up statically. You can configure the path of this folder like so:\n\n    app.set public: './public'\n\nYou can add static assets like stylesheets and images to the `public` folder.\n\n##Templates\n\nAce includes support for rendering CoffeeScript, Eco, EJS, Less, Mustache and Stylus templates. Simply install the relevant module and the templates will be available to render.\n\nFor example, install the [eco](https://github.com/sstephenson/eco) module and the `@eco` function will be available to you.\n\n    app.get '/users/:name', ->\n      @name = @route.name\n      @eco 'user/show'\n\nThe `@eco` function takes a path of the Eco template. By default, this should be located under a folder named `./views`.\nThe template is rendered in the current context, so you can pass variables to them by setting them locally.\n\nIf a file exists under `./views/layout.*`, then it'll be used as the application's default layout. You can specify a different layout with the `layout` option.\n\n    app.get '/users', ->\n      @users = User.all().wait()\n      @mustache 'user/list', layout: 'basic'\n\n##JSON\n\nYou can serve up JSON and JSONP with the `@json` and `@jsonp` helpers respectively.\n\n    app.get '/users', ->\n      @json {status: 'ok'}\n\n    app.get '/users', ->\n      @users = User.all().wait()\n      @jsonp @users\n\nBy default `@jsonp` uses the `@params.callback` parameter as the name of its wrapper function.\n\n##Fibers\n\nEvery request in Ace is wrapped in a Fiber. This means you can do away with the callback spaghetti that Node applications often descend it. Rather than use callbacks, you can simply pause the current fiber. When the callback returns, the fibers execution continues from where it left off.\n\nIn practice, Ace provides a couple of utility functions for pausing asynchronous functions. Ace adds a `wait()` function to `EventEmitter`. This transforms asynchronous calls on libraries such as [Sequelize](http://sequelizejs.com).\n\nFor example, `save()` is usually an asynchronous call which requires a callback. Here we can just call `save().wait()` and use a synchronous style.\n\n    app.get '/projects', ->\n      project = Project.build(\n        name: @params.name\n      )\n\n      project.save().wait()\n\n      @sleep(2000)\n\n      \"Saved project: #{project.id}\"\n\nThis fiber technique also means we can implement functionality like `sleep()` in JavaScript, as in the previous example.\n\nYou can make an existing asynchronous function fiber enabled, by wrapping it with `Function::wait()`.\n\n    syncExists = fs.exists.bind(fs).wait\n\n    if syncExists('./path/to/file')\n      @sendFile('./path/to/file)\n\nFibers are pooled, and by default there's a limit of 100 fibers in the pool. This means that you can serve up to 100 connections simultaneously. After the pool limit is reached, requests are queued. You can increase the pool size like so:\n\n    app.pool.size = 250\n\n##Cookies & Session\n\nSessions are enabled by default in Ace. You can set and retrieve data stored in the session by using the `@session` object:\n\n    app.get '/login', ->\n      user = User.find(email: @params.email).wait()\n      @session.user_id = user.id\n      @redirect '/'\n\nYou can retrieve cookies via the `@cookie` object, and set them with `@response.setCookie(name, value)`;\n\n    app.get '/login', ->\n      token = @cookies.rememberMe\n      # ...\n\n##Filters\n\nAce supports 'before' filters, callbacks that are executed before route handlers.\n\n    app.before ->\n      # Before filter\n\nBy default before filters are always executed. You can specify conditions to limit that, such as routes.\n\n    app.before '/users*', ->\n\nThe previous filter will be executed before any routes matching `/users*` are.\n\nAs well as a route, you can specify a object to match the request against:\n\n    app.before method: 'POST', ->\n      ensureLogin()\n\nFinally you can specify a conditional function that'll be passed the request's `env`, and should return a boolean indicating whether the filter should be executed or not.\n\n    app.before conditionFunction, ->\n\nIf a filter changes the response status to anything other than 200, then execution will halt.\n\n    app.before ->\n      if @request.method isnt 'GET' and !@session.user\n        @head 401\n\n##Context\n\nYou can add extra properties to the routing callback context using `context.include()`:\n\n    app.context.include\n      loggedIn: -> !!@session.user_id\n\n    app.before '/admin*', ->\n      if @loggedIn()\n        @ok\n      else\n        @redirect '/login'\n\nThe context includes a few utilities methods by default:\n\n    @redirect(url)\n    @sendFile(path)\n    @head(status)\n\n    @basicAuth (user, pass) ->\n      user is 'foo' and pass is 'bar'\n\n##Configuration\n\nAce includes some sensible default settings, but you can override them using `@set`, passing in an object of names to values.\n\n    @app.set static:   true       # Serve up file statically from public\n             sessions: true       # Enable sessions\n             port:     1982       # Server port number\n             bind:     '0.0.0.0'  # Bind to host\n             views:    './views'  # Path to 'views' dir\n             public:   './public' # Path to 'public' dir\n             layout:   'layout'   # Name of application's default layout\n             logging:  true       # Enable logging\n\nSettings are available on the `@settings` object:\n\n    if app.settings.logging is true\n      console.log('Logging is enabled')\n\n##Middleware\n\nMiddleware sits on the request stack, and gets executed before any of the routes. Using middleware, you can alter the request object such as HTTP headers or the request's path.\n\nAce sits on top of [Strata](http://stratajs.org/), so you can use any of the middleware that comes with the framework, or create your own.\n\nFor example, we can use Ace's [methodOverride](https://github.com/mjijackson/strata/blob/master/lib/methodoverride.js) middleware, enabling us to override the request's HTTP method with a `_method` parameter.\n\n    strata = require('ace').strata\n    app.use strata.methodOverride\n\nThis means we can use HTML forms to send requests other than `GET` or `POST` ones, keeping our application RESTful:\n\n    <form action=\"<%= @post.url() %>\" method=\"post\">\n      <input type=\"hidden\" name=\"_method\" value=\"delete\">\n      <button>Delete</button>\n    </form>\n\nFor more information on creating your own middleware, see [Strata's docs](http://stratajs.org/manual/5).\n\n##Credits\n\nAce was built by [Alex MacCaw](http://alexmaccaw.com) and [Michael Jackson](http://mjijackson.com/).",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/maccman/ace/issues"
  },
  "_id": "ace@0.0.2",
  "dist": {
    "shasum": "b34d45889191d426e23122233ea2f4d7d09c5a2c"
  },
  "_from": "ace@*",
  "_resolved": "https://registry.npmjs.org/ace/-/ace-0.0.2.tgz"
}
